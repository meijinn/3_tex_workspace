\mysection{44ページ目翻訳}

2.2探索アルゴリズム

このセクションでは、基本的な問題と、その問題を解決する2つのアルゴリズムを説明する。
また、これらのアルゴリズムの効率も比較する。アルファベット順の単語リストが与えられたとき、
特定の単語がリスト上のどこに現れるかどうかを判断したいと思う。例えば、ある飛行機に乗る予定の乗客のアルファベット順のリストに、
個人の名前があるかどうかを知りたい場合がある。このような場合、私たち（あるいはコンピュータ）は、どのようにリストを検索して、
その名前が含まれているかどうかを判断するのでしょうか？(単語のリストをアルファベット順に並べる2つのアルゴリズムが2.3節で紹介されています)。
簡単な方法は、リストの先頭から順番に、名前が見つかるか、リストの最後に来るまで検索することです。
このアルゴリズムは、しばしば逐次探索アルゴリズムと呼ばれる。リスト上のk番目の位置にある単語を$w(k)$とする。
リスト上に$n$個の単語がある場合、$w(n)$とする。目的の単語がKEYだとすると、ある$k、1< k < n$に対して$W(k)=$KEYかどうかが問題となる。
すると、単語はアルファベット順に、$W(1), W(2), ...$となる。
アルゴリズム2.2（逐次探索アルゴリズム）。[$T_b$は、与えられた単語KEYがアルファベット順のリストに現れるかどうかを決定する
$W(I), W(2),...,W(n)$の単語のアルファベット順のリストにKEYが現れるかどうかを判定し、現れる場合はリスト上の位置を表示する。
リスト上の位置を表示する]。1. [リスト上の$k$番目の単語がKEYである場合、その位置を出力し、アルゴリズム
を終了する。]
$k = 1-n$まで (a) $W(k) = KEY$なら
$k$を出力して停止する。2.Not on listを出力する。
確かに、アルゴリズム2.2が終了するまでに、$n$回もの比較(リスト上の最新の単語がKEYであるかどうかのチェック)を要するかもしれない。
したがって、複雑さを直接ne単位で測るのではなく、比較の回数で測るなら、このアルゴリズムの（最悪の場合の）複雑さは、$n$または$O(n)$となる。
この逐次探索アルゴリズムは、リスト上の単語がアルファベット順に与えられているという事実を利用していないことに注意されたい。
次に、アルファベット順のリストの中から与えられた単語を検索する「分割統治（divide-and-conquer）」技法を説明する。
分割統治とは、問題をより小さなサブ問題に分割することで、より簡単に解決できるようにすることである。
より簡単に解くことができる、という意味である。バイナリサーチアルゴリズムは、アルゴリズム2,2と同じ課題を達成するが、
より効率的である。つまり、最悪の場合、大きい数に対して比較回数が大幅に少なくなる。$x$を実数とする。$x$の階$x$は、$x$より小さい最大の整数である。