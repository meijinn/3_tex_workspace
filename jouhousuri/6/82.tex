\mysection{82ページ目翻訳}

定理3.11。
$T$ を接続グラフ $G$ の深さ優先探索木とする。
$dfi(u) < dfi(v)$ である $G$ のエッジ $uv$ は、$uv$ が $T$ と $l(v)$ のエッジである場合に限り、$G$ のブリッジになります。 ) $> dfi(u)$。

証拠。
まず、$uv$ が $dfi(u) < dfi(v)$ である $G$ のブリッジであると仮定します。 
前に述べたように、$uv$ は $T$ のエッジであり、$v$ は $u$ の子です。 $l(v) \leq dfi(u)$ の場合、
定理 3.8 より、$v$ または $v$ の子孫から $u$ または $u$ の祖先までのバックエッジが存在します。
したがって、$uv$ は $G$ のブリッジではないため、$v$ または $v$ の子孫から $u$ または $u$ の親へのバックエッジが存在する必要があります。
しかし、そうすると $l(v) \leq dfi(u)$ となり、仮説に反します。

グラフのブロックを知ることが重要な状況があります。
たとえば、第 9 章では、グラフのブロックにのみ適用できるアルゴリズムが示されています。
次に、深さ優先検索を使用してグラフのブロックを見つけるアルゴリズムを開発する方法について説明します。
グラフ $G$ の深さ優先検索が実行されると、当然のことながら、検索は $G$ 内のコンポーネントからコンポーネントへと進みます。
$G$ が接続されているとします。 $G$ に少なくとも 2 つのブロックがある場合、
$G$ には少なくとも 2 つのエンドブロック ($G$ のカット頂点を 1 つだけ含むブロック) があります。

$G$ のカット頂点ではない頂点 $r$ から検索が始まるとします。
$r$ がエンドブロックに属するかどうかに関係なく、検索は最終的にエンドブロックに進むかどうかにかかわらず、
検索は最終的にエッジ $uv$ で初めてエンドブロック $B$ に進みます。 ここで、$u$ は、$G$ 内の $B$ の一意のカット頂点です。
定理 3.10 より、$u$ がカット頂点であることが確認できます。

$B$ に入ってから完全に探索されるまで、$B$ に留まります。
したがって、定理 3.9 より、$v$ は $B$ における $u$ の唯一の子です。
つまり、$B$ のすべての頂点は $v$ の子孫です。 このため、スタックを使用します。
$B$ の頂点は、最初にアクセスされた順序でスタックに配置されます。
$uv$ をバックトラックしたときに、$u$ がカット頂点であることがわかった場合は、
スタックの最上位から $v$ までの頂点を出力します。 これらの頂点は $u$ とともに、$G$ から $B$ を誘導します。
プロセスは $u$ で続行され、検出するブロックが 1 つ減りました。
実際、アルゴリズムは、$G$ のすべてのブロックが決定されるまで、エンドブロックを連続的に検出します。

検索をカット頂点 $r$ から開始する必要がある場合、
アルゴリズムは $r$ を含まないすべてのブロックを検出し、以前と同様に出力します。
$r$ を含むブロックは、定理 3.9 を使用して見つけることができます。
$r$ まで後戻りすると、たとえばエッジに沿って $rx$ が決定されます。
このブロックは、$r$ とともに $x$ までのスタック上の頂点によって誘発されるブロックです。