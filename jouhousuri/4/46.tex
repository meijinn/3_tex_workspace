\mysection{46ページ目翻訳}

サーチアルゴリズム
2.$W(k)$は$W()$と$W(e)$の中間の単語である] While fs l do
(a) k -. (b) [リストのk番目の単語がKEYの場合
(b)[リストのk番目の単語がKEYであれば、そのlo cationを出力してアルゴリズム
を終了する。］W(k) = KEYなら、kを出力して停止する。
(c) [KEYが現在のサブリストの中央の単語の前にある場合、新しいサブリストは$W(f)$と$W(k -1)$の間の単語で構成される]。KEY $< W(k)$であれば、$-k-1$である。
(a) U KEYが現在のサブリストの中央の単語に続く場合、新しいサブリストは$W(k + 1)$と$W(e)$の間の単語からなる]。KEY$>W(k)$であれば、$f-k+1$である。3.Not on listを出力する。
ここで、バイナリーサーチアルゴリズムの（ワーストケースの）複雑さを決定する。ステップ1と3はそれぞれ一度だけ実行され、どちらも一定の数の演算を伴うことに注意してください。したがって、これらの複雑さは$O(1)$である。
ステップ2が実行される最大回数を$B(n)$とすると、$B(n)$は、ステップ2が実行される最大回数を表す。確かに、この最大回数は、キーワードがリストに現れないときに発生する。
ステップ2を初めて実行した後、検討すべき単語は最大で$5J$個のリストとなる。したがって
$B(n) s 1 + B()$となる。
強引な帰納法を用いて、次のことを証明する。
$B(n) = 1 + log, n = 1+log n $となる。
(2.1)
(2.2)
$n=1$の場合、ステップ2は一度しか行われないので、この場合、不等式(2.2)が満たされる。ここで、(2.2)が1< n s kの整数nについて、ある正の整数kについて成立すると仮定し、次のことを示す。
B(k + 1) <1+log(k + 1)である。
B(k + 1) s1+B(|)である。
B(k1) s 1 + log(|!) I +log()、
最初の不等式は帰納的仮説から導かれる。したがって、B(k + 1)s2+ log(k + 1)- log 2 =1 + log(k + )となり、B(n) = O(log n) となる。ステップ2を実行するたびに、最大で2つの比較と2つの代入演算が必要になるので
の演算が行われるので、ステップ2の複雑さはB(n)のオーダーになる、
すなわち、O(log n)となる。
(2.1)による、
ただし

となり、最初の不等式は帰納的仮説から導かれる。したがって

B(k+1) <= 2 + log (k+1) - log 2 = 1 + log (k+1) です。

となり、所望の結果が得られる。その結果、B(n) = O(log n)となる。Step2を実行するたびに、最大で2つの比較が必要となり、2つの割り当て操作が行われるため、結果としてStep2の複雑さはB（n）のオーダー、すなわちO（log n）である。